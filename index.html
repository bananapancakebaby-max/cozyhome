<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cozy Farm World</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { overflow: hidden; background: #d4e4d0; font-family: 'Segoe UI', sans-serif; }
  canvas { display: block; }
  #ui-overlay { position: fixed; top: 16px; left: 16px; z-index: 10; }
  #player-badge {
    background: rgba(45, 65, 45, 0.85); backdrop-filter: blur(8px);
    color: #e8f0e4; padding: 8px 16px; border-radius: 20px; font-size: 13px;
    display: flex; align-items: center; gap: 8px;
  }
  #player-badge .dot { width: 8px; height: 8px; background: #7ecd6a; border-radius: 50%; animation: pulse 2s infinite; }
  #controls-hint { position: fixed; top: 16px; right: 16px; z-index: 10; display: flex; flex-direction: column; gap: 6px; }
  .hint-pill { background: rgba(45,65,45,0.7); backdrop-filter: blur(8px); color: #e8f0e4; padding: 6px 14px; border-radius: 16px; font-size: 12px; text-align: right; }
  #chat-box { position: fixed; bottom: 16px; right: 16px; width: 280px; z-index: 10; background: rgba(45,65,45,0.88); backdrop-filter: blur(10px); border-radius: 14px; overflow: hidden; }
  #chat-header { padding: 10px 14px; font-size: 12px; font-weight: 600; color: #7ecd6a; letter-spacing: 1.5px; text-transform: uppercase; border-bottom: 1px solid rgba(126,205,106,0.15); }
  #chat-messages { height: 120px; padding: 10px 14px; overflow-y: auto; font-size: 12px; color: #c8d8c4; }
  #chat-input-row { display: flex; padding: 8px; gap: 6px; border-top: 1px solid rgba(126,205,106,0.15); }
  #chat-input { flex: 1; background: rgba(255,255,255,0.08); border: none; border-radius: 10px; padding: 8px 12px; color: #e8f0e4; font-size: 12px; outline: none; }
  #chat-input::placeholder { color: rgba(200,216,196,0.4); }
  #chat-send { background: #7ecd6a; border: none; border-radius: 10px; width: 34px; height: 34px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
  #chat-send:hover { background: #6bba58; }
  #chat-send svg { width: 16px; height: 16px; fill: #2d412d; }
  @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.4} }
  #click-indicator { position: fixed; pointer-events: none; z-index: 5; width: 20px; height: 20px; border: 2px solid rgba(126,205,106,0.6); border-radius: 50%; transform: translate(-50%,-50%) scale(0); opacity: 0; }
  #click-indicator.active { animation: clickRing 0.6s ease-out forwards; }
  @keyframes clickRing { 0%{transform:translate(-50%,-50%) scale(0);opacity:1} 100%{transform:translate(-50%,-50%) scale(2.5);opacity:0} }
  #loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #d4e4d0; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; transition: opacity 0.5s; }
  #loading.done { opacity: 0; pointer-events: none; }
  #loading-text { color: #4a6a40; font-size: 16px; margin-top: 16px; }
  #loading-bar-bg { width: 200px; height: 6px; background: rgba(74,106,64,0.2); border-radius: 3px; margin-top: 10px; }
  #loading-bar { height: 100%; width: 0%; background: #7ecd6a; border-radius: 3px; transition: width 0.3s; }
</style>
</head>
<body>
<div id="loading">
  <div id="loading-text">Loading farm... üåø</div>
  <div id="loading-bar-bg"><div id="loading-bar"></div></div>
</div>
<div id="ui-overlay"><div id="player-badge"><span class="dot"></span><span>ONLINE ¬∑ <strong>1 Player</strong></span></div></div>
<div id="controls-hint">
  <div class="hint-pill">üñ± Click ground to move</div>
  <div class="hint-pill">‚Üî Drag to rotate camera</div>
  <div class="hint-pill">üîç Scroll to zoom</div>
</div>
<div id="chat-box">
  <div id="chat-header">üí¨ FARM CHAT</div>
  <div id="chat-messages"><div style="opacity:0.5;font-style:italic;">Welcome to the farm! üåø</div></div>
  <div id="chat-input-row">
    <input type="text" id="chat-input" placeholder="Type a message..." />
    <button id="chat-send"><svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg></button>
  </div>
</div>
<div id="click-indicator"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xd4e4d0);
scene.fog = new THREE.FogExp2(0xd4e4d0, 0.012);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 200);
camera.position.set(14, 14, 14);
camera.lookAt(0,0,0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.prepend(renderer.domElement);

// Lighting
scene.add(new THREE.AmbientLight(0xfff5e6, 0.6));
const dl = new THREE.DirectionalLight(0xfff0d4, 0.9);
dl.position.set(10,20,8); dl.castShadow = true;
dl.shadow.mapSize.set(1024,1024);
dl.shadow.camera.near=0.5; dl.shadow.camera.far=60;
dl.shadow.camera.left=-20; dl.shadow.camera.right=20;
dl.shadow.camera.top=20; dl.shadow.camera.bottom=-20;
dl.shadow.bias=-0.001;
scene.add(dl);
const fl = new THREE.DirectionalLight(0xc8e0ff, 0.3);
fl.position.set(-8,10,-6); scene.add(fl);

// Ground slab
const gg = new THREE.Group();
const gt = new THREE.Mesh(new THREE.BoxGeometry(12,0.3,12), new THREE.MeshLambertMaterial({color:0xa8d89a}));
gt.receiveShadow=true; gg.add(gt);
const ge = new THREE.Mesh(new THREE.BoxGeometry(12.02,0.15,12.02), new THREE.MeshLambertMaterial({color:0x6b8c52}));
ge.position.y=-0.2; gg.add(ge);
const gd = new THREE.Mesh(new THREE.BoxGeometry(12,1.0,12), new THREE.MeshLambertMaterial({color:0xb07040}));
gd.position.y=-0.75; gd.castShadow=true; gg.add(gd);
const gb = new THREE.Mesh(new THREE.BoxGeometry(12,0.25,12), new THREE.MeshLambertMaterial({color:0x8b5530}));
gb.position.y=-1.4; gg.add(gb);
scene.add(gg);

const ground = new THREE.Mesh(new THREE.PlaneGeometry(12,12), new THREE.MeshBasicMaterial({visible:false}));
ground.rotation.x=-Math.PI/2; ground.position.y=0.15; scene.add(ground);

// Grass tufts
for(let i=0;i<15;i++){
  const t=new THREE.Mesh(new THREE.BoxGeometry(0.15,0.3,0.15),new THREE.MeshLambertMaterial({color:0x8cc47a}));
  t.position.set((Math.random()-0.5)*10,0.25,(Math.random()-0.5)*10); t.castShadow=true; scene.add(t);
}

// Farmhouse
function mkHouse(x,z){
  const g=new THREE.Group();
  const b=new THREE.Mesh(new THREE.BoxGeometry(4,3,3.5),new THREE.MeshLambertMaterial({color:0xe8675a}));
  b.position.y=1.5;b.castShadow=true;b.receiveShadow=true;g.add(b);
  const r=new THREE.Mesh(new THREE.ConeGeometry(3.2,2,4),new THREE.MeshLambertMaterial({color:0x6b3040}));
  r.position.y=4;r.rotation.y=Math.PI/4;r.castShadow=true;g.add(r);
  const d=new THREE.Mesh(new THREE.BoxGeometry(0.9,1.6,0.1),new THREE.MeshLambertMaterial({color:0x3d1f1f}));
  d.position.set(0,0.8,1.76);g.add(d);
  const wm=new THREE.MeshLambertMaterial({color:0xfff4b8});
  const wg=new THREE.BoxGeometry(0.7,0.7,0.1);
  const w1=new THREE.Mesh(wg,wm);w1.position.set(-1.2,2,1.76);g.add(w1);
  const w2=new THREE.Mesh(wg,wm);w2.position.set(1.2,2,1.76);g.add(w2);
  const c=new THREE.Mesh(new THREE.BoxGeometry(0.6,1.5,0.6),new THREE.MeshLambertMaterial({color:0x8b6050}));
  c.position.set(1.2,4.5,-0.5);c.castShadow=true;g.add(c);
  g.position.set(x,0,z);scene.add(g);
}
mkHouse(1,-1);

// Fallback primitive trees (used if GLB fails to load)
function mkPine(x,z,s){
  const g=new THREE.Group();
  const tr=new THREE.Mesh(new THREE.CylinderGeometry(0.15*s,0.25*s,1.5*s,6),new THREE.MeshLambertMaterial({color:0x8b6848}));
  tr.position.y=0.75*s;tr.castShadow=true;g.add(tr);
  [[0x5a9e4b,1.8,1.8],[0x4d8b40,1.3,2.8],[0x3f7a35,0.8,3.6]].forEach(([c,sz,h])=>{
    const f=new THREE.Mesh(new THREE.ConeGeometry(sz*s*0.6,1.4*s,6),new THREE.MeshLambertMaterial({color:c}));
    f.position.y=h*s;f.castShadow=true;g.add(f);
  });
  g.position.set(x,0,z);scene.add(g);
}
function mkRound(x,z,s){
  const g=new THREE.Group();
  const tr=new THREE.Mesh(new THREE.CylinderGeometry(0.12*s,0.2*s,1.8*s,6),new THREE.MeshLambertMaterial({color:0x9b7858}));
  tr.position.y=0.9*s;tr.castShadow=true;g.add(tr);
  const cr=new THREE.Mesh(new THREE.SphereGeometry(1.2*s,8,6),new THREE.MeshLambertMaterial({color:0x6db85a}));
  cr.position.y=2.6*s;cr.castShadow=true;g.add(cr);
  g.position.set(x,0,z);scene.add(g);
}

// ============ LOAD GLB TREES FROM GITHUB ============
const TREE_URL = 'stylized_pine_tree_tree.glb'; // relative path (same folder)
const loadBar = document.getElementById('loading-bar');

const gltfLoader = new THREE.GLTFLoader();
gltfLoader.load(
  TREE_URL,
  // Success
  (gltf) => {
    const treeModel = gltf.scene;
    treeModel.traverse(child => {
      if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;
      }
    });

    // Place trees at these positions (adjust scale if needed)
    const treePositions = [
      { x: -4, z: -3, scale: 0.02 },
      { x: -3, z: 3, scale: 0.015 },
      { x: 4, z: 3, scale: 0.018 },
    ];

    treePositions.forEach(t => {
      const tree = treeModel.clone();
      tree.position.set(t.x, 0.15, t.z);
      tree.scale.setScalar(t.scale);
      scene.add(tree);
    });

    console.log('GLB trees loaded successfully!');
    loadBar.style.width = '100%';
    setTimeout(() => document.getElementById('loading').classList.add('done'), 300);
  },
  // Progress
  (progress) => {
    if (progress.total) {
      const pct = (progress.loaded / progress.total) * 100;
      loadBar.style.width = pct + '%';
    }
  },
  // Error - fallback to primitive trees
  (error) => {
    console.warn('GLB load failed, using fallback trees:', error);
    mkPine(-4, -3, 0.02);
    mkPine(-3, 3, 0.015);
    mkRound(4, 3, 0.018);
    loadBar.style.width = '100%';
    setTimeout(() => document.getElementById('loading').classList.add('done'), 300);
  }
);

// Flowers
for(let i=0;i<5;i++){
  const fg=new THREE.Group();
  const st=new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,0.4,4),new THREE.MeshLambertMaterial({color:0x6aaa55}));
  st.position.y=0.2;fg.add(st);
  const cs=[0xf5a0b0,0xf0d060,0xffffff,0xc8a0f0];
  const pt=new THREE.Mesh(new THREE.SphereGeometry(0.12,6,4),new THREE.MeshLambertMaterial({color:cs[Math.floor(Math.random()*4)]}));
  pt.position.y=0.45;fg.add(pt);
  const a=Math.random()*Math.PI*2,dd=2+Math.random()*3;
  fg.position.set(Math.cos(a)*dd,0,Math.sin(a)*dd);scene.add(fg);
}

// Fence
const fm=new THREE.MeshLambertMaterial({color:0xc4a46a});
[[-1,2],[1,2],[3,2],[3,0]].forEach(([x,z])=>{
  const p=new THREE.Mesh(new THREE.BoxGeometry(0.15,0.8,0.15),fm);
  p.position.set(x,0.4,z);p.castShadow=true;scene.add(p);
});
const rm=new THREE.MeshLambertMaterial({color:0xb89858});
[[[-1,2],[1,2]],[[1,2],[3,2]],[[3,2],[3,0]]].forEach(([[x1,z1],[x2,z2]])=>{
  const dx=x2-x1,dz=z2-z1,len=Math.sqrt(dx*dx+dz*dz);
  const r=new THREE.Mesh(new THREE.BoxGeometry(len,0.08,0.08),rm);
  r.position.set((x1+x2)/2,0.55,(z1+z2)/2);r.rotation.y=Math.atan2(dz,dx);scene.add(r);
});

// Player sheep
const player=new THREE.Group();
const sb=new THREE.Mesh(new THREE.SphereGeometry(0.55,8,6),new THREE.MeshLambertMaterial({color:0xf5f0e8}));
sb.position.y=0.7;sb.scale.set(1.1,0.9,0.85);sb.castShadow=true;player.add(sb);
const sh=new THREE.Mesh(new THREE.SphereGeometry(0.3,8,6),new THREE.MeshLambertMaterial({color:0x3d3530}));
sh.position.set(0,0.9,0.5);sh.castShadow=true;player.add(sh);
[[-0.12,0.95,0.72],[0.12,0.95,0.72]].forEach(p=>{
  const e=new THREE.Mesh(new THREE.SphereGeometry(0.06,6,4),new THREE.MeshLambertMaterial({color:0xffffff}));
  e.position.set(...p);player.add(e);
});
[[-0.12,0.95,0.77],[0.12,0.95,0.77]].forEach(p=>{
  const e=new THREE.Mesh(new THREE.SphereGeometry(0.035,6,4),new THREE.MeshLambertMaterial({color:0x1a1a1a}));
  e.position.set(...p);player.add(e);
});
const legs=[];
const lg=new THREE.CylinderGeometry(0.07,0.07,0.4,5),lm=new THREE.MeshLambertMaterial({color:0x3d3530});
[[-0.25,0.2,0.2],[0.25,0.2,0.2],[-0.25,0.2,-0.2],[0.25,0.2,-0.2]].forEach(p=>{
  const l=new THREE.Mesh(lg,lm);l.position.set(...p);l.castShadow=true;player.add(l);legs.push(l);
});
const nc=document.createElement('canvas');nc.width=128;nc.height=32;
const nx=nc.getContext('2d');
nx.fillStyle='rgba(45,65,45,0.85)';nx.beginPath();nx.roundRect(0,0,128,32,8);nx.fill();
nx.fillStyle='#e8f0e4';nx.font='bold 16px sans-serif';nx.textAlign='center';nx.fillText('AMY',64,22);
const nt=new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(nc),transparent:true}));
nt.scale.set(1.5,0.4,1);nt.position.y=1.6;player.add(nt);
player.position.set(0,0,2);scene.add(player);

const ps=new THREE.Mesh(new THREE.CircleGeometry(0.5,16),new THREE.MeshBasicMaterial({color:0,transparent:true,opacity:0.12}));
ps.rotation.x=-Math.PI/2;ps.position.set(0,0.16,2);scene.add(ps);

// Movement
let targetPos=new THREE.Vector3(0,0,2),isMoving=false;
const ray=new THREE.Raycaster(),mss=new THREE.Vector2();
renderer.domElement.addEventListener('click',e=>{
  if(isDrag) return;
  mss.x=(e.clientX/innerWidth)*2-1; mss.y=-(e.clientY/innerHeight)*2+1;
  ray.setFromCamera(mss,camera);
  const h=ray.intersectObject(ground);
  if(h.length){targetPos.copy(h[0].point);targetPos.y=0;isMoving=true;
    const ind=document.getElementById('click-indicator');
    ind.style.left=e.clientX+'px';ind.style.top=e.clientY+'px';
    ind.classList.remove('active');void ind.offsetWidth;ind.classList.add('active');
  }
});

// Camera
let isDrag=false,pmx=0,pmy=0,camA=Math.PI/4,camP=0.5,camD=14;
renderer.domElement.addEventListener('mousedown',e=>{isDrag=false;pmx=e.clientX;pmy=e.clientY;});
renderer.domElement.addEventListener('mousemove',e=>{
  if(e.buttons!==1)return;
  const dx=e.clientX-pmx,dy=e.clientY-pmy;
  if(Math.abs(dx)>3||Math.abs(dy)>3)isDrag=true;
  camA-=dx*0.005;camP=Math.max(0.2,Math.min(1.2,camP+dy*0.005));
  pmx=e.clientX;pmy=e.clientY;
});
renderer.domElement.addEventListener('wheel',e=>{camD=Math.max(6,Math.min(22,camD+e.deltaY*0.02));});
renderer.domElement.addEventListener('touchstart',e=>{if(e.touches.length===1){pmx=e.touches[0].clientX;pmy=e.touches[0].clientY;isDrag=false;}});
renderer.domElement.addEventListener('touchmove',e=>{
  if(e.touches.length===1){
    const dx=e.touches[0].clientX-pmx,dy=e.touches[0].clientY-pmy;
    if(Math.abs(dx)>3||Math.abs(dy)>3)isDrag=true;
    camA-=dx*0.005;camP=Math.max(0.2,Math.min(1.2,camP+dy*0.005));
    pmx=e.touches[0].clientX;pmy=e.touches[0].clientY;
  }
  e.preventDefault();
},{passive:false});

// Chat
const ci=document.getElementById('chat-input'),cm=document.getElementById('chat-messages');
function sendMsg(){
  const m=ci.value.trim();if(!m)return;
  const d=document.createElement('div');d.style.marginTop='6px';
  d.innerHTML='<span style="color:#7ecd6a;font-weight:600;">Amy:</span> '+m;
  cm.appendChild(d);cm.scrollTop=cm.scrollHeight;ci.value='';
}
document.getElementById('chat-send').addEventListener('click',sendMsg);
ci.addEventListener('keydown',e=>{if(e.key==='Enter')sendMsg();});

// Animate
let t=0;
function animate(){
  requestAnimationFrame(animate); t+=0.016;
  if(isMoving){
    const dx=targetPos.x-player.position.x,dz=targetPos.z-player.position.z;
    if(Math.sqrt(dx*dx+dz*dz)>0.1){
      player.position.x+=dx*0.06;player.position.z+=dz*0.06;
      player.rotation.y=Math.atan2(dx,dz);
      player.position.y=Math.abs(Math.sin(t*8))*0.08;
      legs.forEach((l,i)=>l.rotation.x=Math.sin(t*10+i*Math.PI)*0.3);
    }else{isMoving=false;player.position.y=0;legs.forEach(l=>l.rotation.x=0);}
  }else{sb.scale.y=0.9+Math.sin(t*2)*0.02;}
  ps.position.x=player.position.x;ps.position.z=player.position.z;
  const cx=player.position.x+Math.sin(camA)*camD*Math.cos(camP);
  const cy=Math.sin(camP)*camD;
  const cz=player.position.z+Math.cos(camA)*camD*Math.cos(camP);
  camera.position.lerp(new THREE.Vector3(cx,cy,cz),0.05);
  camera.lookAt(new THREE.Vector3(player.position.x,1,player.position.z));
  renderer.render(scene,camera);
}
animate();
addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight);});
</script>
</body>
</html>
